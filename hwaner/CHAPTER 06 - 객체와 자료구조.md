#1. 자료구조 vs 객체
- 자료구조
  - 데이터 그 자체
  - 자료를 공개
  - 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체가 되지 않음(getter, setter)
    - 추상화를 한것이 아니기 때문
- 객체
  - 비즈니스 로직과 관련이 있음
  - 자료를 숨기고, 추상화 / 자료를 다루는 함수만 공개
  - 추상 인터페이스를 제공해 사용자가 구현을 모른채 자료의 핵심을 조작 가능
    - 다형성 활용

- 자료구조를 사용하는 절차적인 코드는 기본 구조를 변경하지 않고 새 함수를 추가하기는 쉽다.
    - 허나, 새로운 구조를 추가하기는 어렵다.(함수를 다 고쳐야하기 때문)
- 객체 지향코드는 기존 함수를 변경하지 않고, 새로운 클래스를 추가하기가 쉽다.
  - ex. Shape / Circle 등등이 area() 메서드를 가진다
  - 허나, 새로운 함수를 추가하기는 어렵다.(모든 클래스를 고쳐야하기 때문)

#2. 디미터 법칙
- 예를들어 A -> B -> C 가 있을 때,
  클래스 C, 자신이 생성한 객체, 자신의 인수로 넘어온 객체, C 인스턴스 변수에 저장된 객체

    만!!! 호출해야 한다.
- 휴리스틱: 경험에 기반하여 문제를 해결하기 위해 발견한 방법 / 의사결정을 단순화하기 위한 법칙들
  - 즉, 경험적으로 만들어낸 법칙

참고: https://blog.knoldus.com/the-law-of-demeter/

** 기차 충돌: 디미터의 법칙에 어긋나는 상황

#3. DTO
- 대표적인 자료구조!
- Data Transfer Object
- 로직이 없이 필드만 가진다(자료구조)
** Beans: java beans: 데이터 표현이 목적인 자바 객체
  - 멤버 변수는 private 속성이다
  - getter setter를 가진다
    - 요즘엔 public 접근을 하기도 함(Kotlin)

#4. Active Record
- Database row 를 객체에 맵핑하는 패턴
- 뿐만 아니라 db에 대한 접근 포함(생성, 수정 등등) (자바개발하면서 보긴 힘듬) (ex. Ruby on rails)

*** 주로 사용하는 패턴: Data Mapper
- row 를 담는 객체와 db에 접근하는 객체가 분리되어 있음
- ex. Person 은 값만 담고 있고 Person Mapper 는 생성 수정.
    ->> Hibernate
- 참고: https://martinfowler.com/eaaCatalog/dataMapper.html

**** 둘다 결국 ORM 패턴 중 하나임. 공부해 볼 것.

-> 하나의 의존성. 이어이어 불러오기 ㄴㄴ.

