높은 추상화 수준 시스템 수준에서도 깨끗함을 유지하는 방법

## **[ 시스템 제작과 사용을 분리 ]**

- 소프트웨어 시스템은 애플리케이션 **객체를 제작**하고 의존성을 서로 연결하는 **준비 과정과 런타임 로직을 분리**해야 한다.
- 시작 단계는 모든 애플리케이션이 풀어야 할 관심사(concern)다. 하지만 불행히도 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다.

```java
/* 초기화 지연, 계산 지연 기법 */
public Service getService(){
  if(service == null){
    service = new MyServiceImpl(); // 이게 모든 시작에서 적합한 기본값일까? 
  }
}
```

- 초기화 (Lazy Initialization) / 계산 지연 (Lazy Evaluation)
    - 장점 1) 실제로 **필요할 때까지 객체를 생성하지 않음** -> 불필요한 부하가 걸리지 않음 (속도 빠름)
    - 장점 2) 어떤 경우에도 **null 포인터를 반환하지 않음**
    - 하지만 getService 메소드의 MyServiceImple() 이 모든 상황에 적합한 객체는 아니다. getService 메소드를 포함한 클래스가 전체 문맥을 알아야할지, 어떤 객체를 어떤 시점에서 사용해야할지 등을 고려.

이와 같은 문제를 위해 시스템 생성과 사용을 분리하는 “**Main 분리 방법**”이 있다.

**[ Main 분리 ]**

: **생성**과 관련된 코드는 **모두 main이나 main이 호출하는 모듈**로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정하자.

- main에서 시스템에 필요한 모든 객체를 생성하고 이를 애플리케이션에 넘긴다 → 애플리케이션은 객체를 사용하기만 함 (즉, **애플리케이션은 main이나 객체 생성과정을 모른다**.)

**[ 팩토리 ]**

: **때로는 객체가 생성되는 시점을 애플리케이션이 결정**해야 한다.

- ABSTRACT FACTORY 패턴 사용.

  : 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공한다.


**[ 의존성 주입 (Dependency Injection) ]**

: **사용과 제작을 분리**하고, **제어 역전 기법을 의존성 관리에 적용**한 메커니즘

- **제어 역전** (단일 책임 원칙)

  : 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기고, 새로운 객체는 전달받은 책임만 맡음

  → ‘책임’ = ‘main’ 루틴, ‘컨테이너’

- **의존성 주입** : JNDI 검색 + 클래스가 의존성을 해결 X

  → 의존성 주입 방법 : setter 메소드 제공, 생성자 인수 제공

  → JNDI 검색 (의존성 주입을 부분적으로 구현한 기능)

  : **호출하는 객체는 실제로 반환되는 객체의 유형을 제어하지 않는다**. 대신 호출하는 객체는 의존성을 능동적으로 해결한다.

- 스프링 프레임워크는 자바 DI 컨테이너를 제공한다. 객체 사이 의존성은 XML 파일에 정의.

---

## **[ 확장 ]**

소프트웨어 시스템은 물리적인 시스템과 다르다.

관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

**[ 횡단(cross-cutting) 관심사 ]  → 2가지 포인트 - 완전 반대 아닌가?**

- EJB2 아키텍처는 일부 영역에서 관심사를 거의 완벽하게 분리한다.

  → 예) 원하는 트랜잭션, 보안, 일부 영속적인 동작은 소스코드가 아니라 배치 기술자에서 정의

- 애플리케이션의 객체 경계를 넘나들며 **모든 객체가 전반적으로 동일한 방식을 이용**하게 만듦.

## [ 자바에서 사용하는 관점(매커니즘) 3가지 ]

**[ 01. 자바 프록시 ]**

- 자바 프록시는 **단순한 상황에 적합**하다.
    - 예) 개별 객체나 클래스에서 메서드 호출을 감싸는 경우
    - JDK 가 제공하는 동적 프록시는 인터페이스만 지원하므로, 클래스 프록시를 쓰려면 바이트 코드 처리 라이브러리가 따로 필요함.
- 프록시를 사용하면 **깨끗한 코드 작성이 어렵고**, 시스템 단위로 **실행 ‘지점’을 명시하는 메커니즘도 제공하지 않는다**.

**[ 02. 순수 자바 AOP 프레임워크 ]**

- 여러 자바 프레임워크는 내부적으로 프록시를 사용함
    - 스프링 - 비즈니스 논리를 POJO로 구현
- **POJO 기반**으로 **프레임워크에 대한 종속성이 전혀 없는 상태로 진행**이 가능하다. 그러기 때문에 테스트 작성하는 부분에서 유리하고 확장도 쉬워진다.
- EJB3 : XML 설정 파일과 Java5 annotation 기능을 사용해 횡단 관심사를 선언적으로 지원하는 스프링 모델을 따름.
    - 일부 상세한 엔티티 정보는 annotation에 포함되어 그대로 남아있지만, 모든 정보가 annotation 속에 있으므로 코드 자체는 깔끔해짐 (테스트하고 유지보수 하기가 쉬워짐).

**[ 03. AspectJ 관점 ]**

- AspectJ : 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.

  → 다양한 기능을 제공해주지만 새로운 언어 문법과 사용법을 익히는데 비용이 많이 든다.


---

## **[ 테스트 주도 시스템 아키텍처 구축 ]**

- AOP 프레임워크 관점에서 설계 및 관심사 분리 → 논리를 POJO로 작성(코드 수준에서 아키텍처 관심사를 분리)할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 처음부터 큰 그림을 생각해서 그것을 가지고 디자인, 설계, 개발, 테스트 진행한다면 중간에 큰 문제가 발생했을 때 고치는 것에 대한 심리적인 압박감을 느낀다. 그러므로 단순하게 만들어진 아키텍처를 가지고 지속적으로 확장시켜야 한다.

---

## **[ 의사 결정 최적화 ]**

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
- 결정에 대해 가장 적합한 사람이 책임을 담당하는게 좋지만 해당 결정은 최대한 미루는 것이 좋다. 많은 정보를 얻고 최선의 선택을 할 수 있기 때문이다.

---

## **[ 명백한 가치가 있을 때 표준을 현명하게 사용하라 ]**

- 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고
- 적절한 경험자를 구하기 쉽고
- 좋은 아이디어를 캡슐화하기 쉽고
- 컴포넌트를 엮기 쉽다

---

## **[ 시스템은 도메인 특화 언어 (DSL) 가 필요하다 ]**

- DSL (Domain-Specified Language) : 간단한 스크립트 언어나 표준 언어로 구현한 API
    - 좋은 DSL → 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄여준다.
    - 좋은 DSL → 도메인 전문가가 사용하는 언어로, 도메인 논리를 잘못 구현할 가능성이 줄어든다.
    - 잘하면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.
- DSL 을 사용하면 고차원에서 저차원 정책까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능

---

## **[ 결론 ]**

- 시스템 역시 깨끗해야 한다. 깨끗하지 않으면 도메인 논리를 흐림 > 기민성을 떨어뜨림 > 제품 품질 & 생산성이 떨어짐 > TDD의 장점이 사라짐 > 버그 많아짐 > 구현, 유지보수가 어려워짐.
- POJO를 작성하고 관점 혹은 관점과 유사한 매커니즘을 사용해 각 구현 관심사를 분리해야 한다.
- 설계를 할 때, 실제로 돌아가는 가장 단순한 수단을 사용하자!