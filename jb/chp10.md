## [ 클래스 체계 ]

깨끗한 클래스를 다루기 위해서는 클래스 체계에서 변수 목록을 가장 우선 확인해본다.

(변수 목록) 변수가 나오는 순서 :

1. static public 상수
2. static private 변수
3. private instance 변수
4. public instance 변수 (public 변수는 거의 안 씀)
5. public 메소드
    1. public 함수
    2. private 함수 (public 함수가 호출함)

**[ 캡슐화 ]**

- 변수, 유틸리티 함수는 가능한 공개하지 않는게 좋지만, 같은 패키지 안에서 test code가 함수를 호출하거나 변수를 사용해야 한다면 protected로 선언하여 접근을 허용한다.
- 캡슐화 푸는건 최후의 수단

## **[ 클래스는 작아야 한다 ]**

함수는 물리적인 행 수로 크기를 측정한다면, 클래스는 갖고있는 메소드 개수로 측정한다 (클래스는 책임이 많으면 안됨).

**[ 단일 책임 원칙 ]**

단일 책임 원칙 (Single Responsibility Principle, SRP)

: 클래스, 모듈을 변경할 이유가 단 1개뿐이어야 한다.

- 예시) SuperDashboard - 변경할 이유가 2가지 (좋지않음):
    1. SuperDashboard → S/W 버전 정보를 추적한다
    2. SuperDashboard → 자바 스윙 컴포넌트를 관리한다.

**[ 응집도 (Cohesion) ]**

- 각 클래스 메서드는 클래스 인스턴스 변수를 1개 이상 사용
- **“응집도가 높다” == 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다**
    - 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높아짐
    - 목표 : 응집도가 높아지도록 변수, 메서드를 적절히 분리해 새로운 클래스 2-3개로 쪼개주기
- 응집도를 유지하면 작은 클래스 여럿이 나온다
    - ex) 큰 함수를 쪼개려 하는데, 메서드들이 큰 함수에 정의된 변수 여러개를 사용한다.
        - 해결책 : 변수 4개를 새 함수에 인수로 넘기지 X → 변수 4개를 클래스 인스턴스 변수로 정의 + 메소드들은 독자적인 클래스로 분리

## **[ 변경하기 쉬운 클래스 ]**

대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도하는대로 동작하지 않을 위험이 따른다.

```java
/* 적절한 SQL 문자열을 만드는 Sql 클래스 */
public class Sql {
	public Sql(String table, Column[] columns)
	public String create()
	public String insert(Object[] fields)
	public String selectAll()
	...
}
```

- 문제점 : Sql 클래스를 수정해야만 새로운 SQL문을 생성하거나 기존 SQL문을 수정할 수 있음.
    - 변경할 이유가 2가지이므로 SRP를 위반함
- 해결책 : 각 SQL 문마다 Sql 클래스를 상속받는 파생 클래스 생성 [p.187]
    - 새로운 SQL문 생성하는 방법 (update문을 만들고 싶음)

      : Sql 클래스를 상속받은 UpdateSql 클래스 생성 → UpdateSql 클래스 안에 update문 작성

    - 재구성한 Sql 클래스는
        1. SRP 를 지원
        2. SOLID 원칙의 OCP (Open-Closed Principle) 지원 : 클래스는 확장에 개방적이고 수정에 폐쇄적이어야한다.

           = 파생 클래스 생성 가능 (확정에 개방적) & 다른 클래스를 닫아놓음 (수정에 폐쇄적)


**[ 변경으로부터 격리 ]**

- 요구사항은 변하고 코드도 변한다.
- 인터페이스와 추상 클래스를 사용해서 구현이 미치는 영향을 격리한다.
- 상세한 구현에 의존하는 코드는 테스트가 어렵다.
- ex) Portfolio 클래스를 만들 때, 이 클래스가 외부 TokyoStockExchange 클래스의 API를 사용 (5분마다 값이 변화하는 API) → 테스트코드가 시세 변화에 영향을 받으므로 테스트 코드 만들기 어려워짐
    - 해결책 : 결합도를 낮추기 위해 세부 구현에 의존하는 클래스보다 StockExchange라는 인터페이스를 구현해서 고정된 주가를 반환

      → 결합도를 낮추면 각 시스템 요소가 다른 요소로부터, 다른 변경사항으로부터 잘 격리되어있으므로 유연성과 재사용성이 높아짐!